<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>The Aranasaurus Nest</title>
		<description>Where @aranasaurus keeps his code and things</description>
		<link>http://aranasaurus.com</link>
		<atom:link href="http://aranasaurus.com/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Testability</title>
				<description>&lt;p&gt;I’ve been working on a project at work for the past few months that started with a basic idea of what was
required of it, and then after a series of proof-of-concept demos we now have a better idea of what this
thing needs to do, and more importantly &lt;em&gt;how&lt;/em&gt; it needs to do it. This type of organic development process
is great, but it can have some side effects for the code base. Primarily there are some code paths that
made it into the code base to support some functionality that is no longer required, as well as some
implementations allowing for requirements that have either gone away or changed, leaving some strange
looking implementation artifacts. Secondarily we did not have time to write tests and setup CI and all
those other best practice and stability things. I spent most of my week addressing these two things.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&quot;code-clean-up&quot;&gt;Code clean up&lt;/h1&gt;

&lt;p&gt;We did some refactoring a couple weeks back to get some of the more egregious code smells taken care of, where
we had gone partially down a path for some functionality and then abandoned that bit of functionality, yet the
code still had some artifacts of it left over.&lt;/p&gt;

&lt;p&gt;After (and during) that, it became apparent that the next thing we needed to do (for our sanity), was tests.
It’s really hard to tell when a new feature you’ve added is &lt;em&gt;really&lt;/em&gt; working the way you &lt;em&gt;think&lt;/em&gt; it is. Verifying
a bug-fix didn’t just make a new bug in the process is also really hard when you’ve no tests to prove it.&lt;/p&gt;

&lt;p&gt;In looking at writing some tests for the project we quickly found that some restructuring was going to be required.
And that is what I’ve been doing with most of my week; Refactoring a bunch of functioning code into testable
units.&lt;/p&gt;

&lt;h1 id=&quot;testable-units&quot;&gt;Testable Units&lt;/h1&gt;

&lt;p&gt;The first thing I did was diagram all of the components as they were currently implemented and map out the
communication points between them. That basically gave me each component’s current API. Sure there are easier
ways to do this, but visualizing it was very helpful for me. It allowed me to move things around and really get
the big picture (pun!) in my head all at once.&lt;/p&gt;

&lt;p&gt;Then I drew up a new diagram which moved some of the responsibilities around from one component to another. This
involved collapsing a couple classes into other classes where the complexity added for communication between the
classes did not outweigh the benefit from separating them. There were also cases where I made a new class to
separate out the more complicated pieces where the benefits of separation &lt;em&gt;did&lt;/em&gt; outweigh the complexity imposed
by communication.&lt;/p&gt;

&lt;p&gt;I did a few iterations on this diagram and boiled it down to what I thought was the core set of components needed
with very specific inputs and outputs defined for their interfaces and then went over it with the rest of my team.
The new design made sure that each component had very specific inputs and outputs that could be generated by hand,
as opposed to the previous design which took a lot of the data required to do its work either from the operating
system directly or from internal properties which were the output of other processes.&lt;/p&gt;

&lt;p&gt;Therein lies the key to making the thing testable: specific inputs and outputs and compartmentalized actions.
The most basic requirements to make something ‘Testable’.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;This all may sound obvious, at least it does to me upon review, but when dealing with things like location as
do most things I work on at work, crafting these things based on inputs and outputs of your own code as opposed
to events from the device/system becomes less straight forward. This week’s refactor was a bit of revelation
in this regard for me, and I wanted to write about it. So here we are, this is me, telling you that separation
of concerns and clearly defined, testable APIs with discrete inputs and outputs are a good thing. You probably
already knew that, but sometimes it’s worth saying again.&lt;/p&gt;

&lt;p&gt;The other thing of note here is that the mere process of making this code &lt;em&gt;testable&lt;/em&gt;, led to restructuring it
in a way that made it far more loosely coupled, which is an improvement in stability even without having written
a single test.&lt;/p&gt;

</description>
				<pubDate>Sat, 08 Nov 2014 23:05:24 -0800</pubDate>
				<link>http://aranasaurus.com/2014/11/08/testability/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/11/08/testability/</guid>
			</item>
		
			<item>
				<title>Slaying the C/C++ Dragon</title>
				<description>&lt;p&gt;Work has been pretty busy this week so my off-time has been spent reading more than coding.
And now that I’ve decided that I’ll be making my own “engine” and using C or C++ for a large
portion of it, my next task is to decide between C and C++.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I found &lt;a href=&quot;http://www.amazon.com/C-Easily-SDL2-Stephen-Jones-ebook/dp/B00JVAO3OO&quot;&gt;a book&lt;/a&gt; that sounded like exactly what I needed to see how this could be
done in straight C and it was on Kindle Unlimited so I could just read it for “free”. So I
did, it was pretty short. It did a pretty good job of showing me the &lt;em&gt;how&lt;/em&gt;, I’m just not sure
I agree with all of the &lt;em&gt;whys&lt;/em&gt;. Or, at least, I don’t think the &lt;em&gt;whys&lt;/em&gt; make up for the
limitations imposed by going straight C. So, ultimately I’ve decided I’m going to go with
C++11.&lt;/p&gt;

&lt;p&gt;So I grabbed a copy of &lt;a href=&quot;http://www.stroustrup.com/Tour.html&quot;&gt;&lt;em&gt;A Tour of C++&lt;/em&gt;&lt;/a&gt; to get some familiarity with C++11, since
all of my C++ books are pretty old. Learning C++ has been a long running challenge for me and
this project is my chance to finally slay that dragon.&lt;/p&gt;

&lt;p&gt;I started trying to learn C++ back in high school and had limited success. I started with
a Borland C++ Compiler user’s manual, which was probably my first mistake. I tried several times
over the years and a made a few small things, but never kept with it long enough for the
intricacies of the language to really sink in. I’ve been doing Objective-C professionally for
a few years now though, and that has provided some level of additional comfort with C++, but
this is still going to take quite a bit of learning on my part to actually do this. C++ has
some functionality that Objective-C lacks that I’m really looking forward to getting some
familiarity with (Templates/Generics primarily).&lt;/p&gt;

&lt;p&gt;I’m still reading &lt;em&gt;A Tour of C++&lt;/em&gt;, I’m about halfway through, and I’m feeling more and more
comfortable with C++. I’m hoping to get back to writing some code for the engine next week,
since work should ease up now that our recent deadline/demo has been done and we have a bit
of “slack” time, so I should have more code writing energy when I get home next week.&lt;/p&gt;

&lt;h1 id=&quot;other-stuff&quot;&gt;Other Stuff&lt;/h1&gt;

&lt;h2 id=&quot;pixel-art&quot;&gt;Pixel Art&lt;/h2&gt;

&lt;p&gt;I also stumbled across these &lt;a href=&quot;https://www.youtube.com/user/achebit/playlists&quot;&gt;video series&lt;/a&gt; (both the “How To Pixel Art”
series and the “Pyxel Edit Tutorial Mini Series”) and am now thoroughly inspired
and excited to make my own pixel art! Which is weird for me, I’ve always wanted (not just
needed, but &lt;em&gt;wanted&lt;/em&gt;) to have someone else do art for me, because I’m generally not very
good at it and not really interested in putting in the time to get better at it. However,
after watching those videos I feel like not only &lt;em&gt;can&lt;/em&gt; I do some art, but I really &lt;em&gt;want&lt;/em&gt;
to! So look forward to some of that coming here in the near future.&lt;/p&gt;

&lt;h2 id=&quot;jonathan-blows-new-language&quot;&gt;Jonathan Blow’s New Language&lt;/h2&gt;

&lt;p&gt;I also watched Jonathan Blow’s &lt;a href=&quot;https://www.youtube.com/watch?v=UTqZNujQOlA&quot;&gt;latest talk and demo&lt;/a&gt; about the new game development
focused programming language he wants to create. He has some good points and I look forward
to seeing where he goes with the idea. In his previous talks on the subject he mentioned
how Go-lang was close to being what he wanted out of a programming language for games,
however it’s garbage collected and that meant it was unacceptable (to him) for game
development. I bring that up because the syntax in the demo looks pretty similar to Go, so
that’s interesting. I sent him an email after the first talk suggesting that he look into
modifying Go (it’s an open language) and remove the garbage collection, or work in a way to
disable it and do manual memory management. I didn’t expect to get a response (and didn’t),
but I still think it’s worth looking into, at least.&lt;/p&gt;

</description>
				<pubDate>Sun, 02 Nov 2014 17:13:57 -0800</pubDate>
				<link>http://aranasaurus.com/2014/11/02/slaying-the-dragon/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/11/02/slaying-the-dragon/</guid>
			</item>
		
			<item>
				<title>Game a Week, on Second Thought...</title>
				<description>&lt;p&gt;After just a few days of the game a week challenge I realized that I’m not ready to start that yet. Not if I want
to succeed at it anyway, and not if I want to use my own engine as opposed to Unity or something similar.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I still think the process I was going through of documenting my thought process and progress was helpful and
I’m going to continue to do that while I make my engine and use it to make those first few simple clones
that I was going to do for the Game a Week challenge.&lt;/p&gt;

&lt;p&gt;In other words, I’m not gonna do Game a Week for a few more weeks, but I &lt;em&gt;am&lt;/em&gt; gonna keep posting stuff here
similar to my first few Game a Week posts. I’ll probably go back and edit those posts a little too and structure
them as generic development posts as opposed to Game a Week journal entries. You know… for posterity.&lt;/p&gt;

</description>
				<pubDate>Thu, 30 Oct 2014 16:42:16 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/30/game-a-week-on-second-thought/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/30/game-a-week-on-second-thought/</guid>
			</item>
		
			<item>
				<title>Thoughts on Engine Design and Implementation</title>
				<description>&lt;p&gt;Today I wanted to get it figured out where the line will be drawn as to which logic is written in C/C++ and what
gets done in Lua.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I started off with reading the relevant chapters in &lt;a href=&quot;http://www.lua.org/pil&quot; title=&quot;Programming in Lua, AKA The Lua Bible&quot;&gt;Programming in Lua&lt;/a&gt;. From that I basically came to the
conclusion that the differences between making C functions callable from Lua vs executing Lua scripts from within
C are pretty negligible. So it becomes a matter of preference: Do I want the engine to be rooted in C/C++ with the
ability to delegate game logic implementation off to Lua? Or do I want the engine (and game logic) to be rooted in
Lua and the only C/C++ code being there to expose SDL, OpenGL, and any other C libraries I end up using for physics,
audio, animation, etc to Lua?&lt;/p&gt;

&lt;p&gt;Let’s examine these two options in a bit more detail.&lt;/p&gt;

&lt;h1 id=&quot;engine-in-cc&quot;&gt;Engine in C/C++&lt;/h1&gt;

&lt;p&gt;Doing the engine in C will of course mean more C code needing to be written by me, which I don’t particularly
enjoy. However, it’ll also mean that the hard part of the game(s) will be a bit more straight forward, as there
will only be one level of abstraction, and it’ll be more cleanly separated from the game logic. Basically meaning
I’ll be writing more C/C++ at first, but later on, when I’m doing mostly game-specific implementation, I’ll be in
Lua land.&lt;/p&gt;

&lt;p&gt;Let’s take a look at how this might be modeled.&lt;/p&gt;

&lt;h3 id=&quot;cc-responsibilities&quot;&gt;C/C++ Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Set up window and OpenGL Context.&lt;/li&gt;
  &lt;li&gt;Manage game loops.&lt;/li&gt;
  &lt;li&gt;Maintains a list of game objects.&lt;/li&gt;
  &lt;li&gt;Render loop uses properties on game objects to determine how to draw them.&lt;/li&gt;
  &lt;li&gt;Update loop calls an update function on game objects.&lt;/li&gt;
  &lt;li&gt;Handle input and pass it off to game objects that care about it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lua-responsibilities&quot;&gt;Lua Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Game objects are defined as Lua tables with attributes for location and dimensions and possibly a texture name.&lt;/li&gt;
  &lt;li&gt;Game objects have an update method which allows for updating their attributes every tick.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically this set up boils down to the plumbing and architecture stuff being done in C/C++ and then there being a
communication layer between that scaffolding and all of the game objects, which are implemented in Lua.&lt;/p&gt;

&lt;p&gt;After writing this all out I actually like this method a bit more than I did before doing so. Let’s see what that
process does on the other side.&lt;/p&gt;

&lt;h1 id=&quot;engine-in-lua&quot;&gt;Engine in Lua&lt;/h1&gt;

&lt;p&gt;Doing the engine in Lua has the upside of everything being done in Lua and there being no extra layer between the
engine and entities. However, it does involve figuring out a way to get everything, everywhere bound to Lua, which
probably wouldn’t be too hard, but it just feels kinda dirty and like it will actually hinder dev speed a little
because it’ll be making the hard part of this project a bit more complicated without a lot of payoff.&lt;/p&gt;

&lt;p&gt;Anyway let’s map it out.&lt;/p&gt;

&lt;h3 id=&quot;cc-responsibilities-1&quot;&gt;C/C++ Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Glue code which exposes SDL and OpenGL calls to lua.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lua-responsibilities-1&quot;&gt;Lua Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Everything.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This was less helpful than the C/C++ analysis, but I think I’ve come to my decision at any rate.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Looks like I’ll be doing an engine based in C/C++ (which is another decision I’ll need to make very soon) with
game objects/entities implemented in Lua. Hopefully I’ll be able to get started on actually implementing some
functionality along these lines tonight after the kids go to bed and/or tomorrow!&lt;/p&gt;

</description>
				<pubDate>Sat, 25 Oct 2014 19:21:16 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/25/thoughts-on-engine-design-and-implementation/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/25/thoughts-on-engine-design-and-implementation/</guid>
			</item>
		
			<item>
				<title>Week 1, Day 1</title>
				<description>&lt;p&gt;Getting started on this week’s game on Friday night… The first week was already going to be a little funky
because I’d need to get a few pre-requisite things done:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;ul&gt;
  &lt;li&gt;Decide on a framework and language&lt;/li&gt;
  &lt;li&gt;Get &lt;strong&gt;an&lt;/strong&gt; app built with said framework and language&lt;/li&gt;
  &lt;li&gt;Try to templatize that app a little to make starting fresh each week easier&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first few weeks are going to have a lot more engine development than later weeks as well, since I will
be starting from scratch (aside from what &lt;a href=&quot;http://libsdl.org&quot; title=&quot;SDL2&quot;&gt;SDL&lt;/a&gt; gives me, that is) in that regard. So I’m thinking the
first week is actually going to end up being 1.5 weeks.&lt;/p&gt;

&lt;p&gt;Tonight (and well into the wee hours of the morning) I did a bit of research and eliminated the &lt;a href=&quot;http://golang.org&quot; title=&quot;Go&quot;&gt;go-lang&lt;/a&gt; option
as it still can’t be built to iOS as far as I can tell. I’ve settled on SDL for sure, and got a templatizable
Xcode project started which is building to the Simulator. I found &lt;a href=&quot;http://www.ciaranmccormack.com/sdl-2-0-on-ios-using-xcode-opengl-es-2-0-and-c-11/&quot; title=&quot;SDL 2 on iOS - Ciaran McCormack&quot;&gt;this video&lt;/a&gt; quite helpful
in that endeavor. I started a &lt;a href=&quot;http://github.com/aranasaurus/game-a-week&quot;&gt;github repo&lt;/a&gt; for the whole
challenge and put tonight’s progress in there.&lt;/p&gt;

&lt;p&gt;Tomorrow I’ll need to do a bit more reading about doing Lua bindings, and experiment a bit with that and think
about how/if I want to design the engine with respect to that. I’d really much rather be writing game logic
in Lua than C++ for a myriad of reasons not the least of which being that Lua is just so much easier to write
quickly. Engine work will probably still be in C++ (or even C, for that matter), but I want to spend time really
thinking about the separation of concerns and where it makes sense to do the binding between the two.&lt;/p&gt;

</description>
				<pubDate>Sat, 25 Oct 2014 03:54:15 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/25/week-1-day-1/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/25/week-1-day-1/</guid>
			</item>
		
			<item>
				<title>Game Dev Week</title>
				<description>&lt;p&gt;By day I’m a mobile developer working for &lt;a href=&quot;http://www.esri.com&quot;&gt;Esri&lt;/a&gt; at their &lt;a href=&quot;http://pdx.esri.com&quot;&gt;Portland R&amp;amp;D Center&lt;/a&gt;.
By night (and weekend), when not playing with my kids, I really enjoy making games, though. So recently I took a week off
from the day job to work on a game idea I’ve been rolling around for quite some time (while the kids are at school). I had
a prototype working but I wanted to give it my full attention for a week and see where I could get it in that time. I’ll
talk more about the details of the game in other posts, this one is more about the experience of said “Game Dev Week”.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I started off the week trying to get the &lt;a href=&quot;http://getmoai.com&quot; title=&quot;MOAI SDK&quot;&gt;framework&lt;/a&gt; I had chosen to build and work. I really like the way Moai is
supposed to work: you set up a host for each platform you want to support and write a layer that takes the platform specific
stuff (like inputs) and feeds those things to Moai, then all of your game logic is the same for all platforms but you just
have to write the parts that differ. So I really like the &lt;em&gt;idea&lt;/em&gt; of Moai, but I couldn’t get it to work. I don’t want to
say that there’s anything wrong with Moai, per se, but their documentation leaves a lot to be desired and I just wasn’t dev
enough to get it working with my environment and requirements. I spent 2 days trying to do this and ended up giving up, so
that’s a significant portion of my week essentially wasted.&lt;/p&gt;

&lt;p&gt;The original prototype was done in &lt;a href=&quot;http://love2d.org&quot; title=&quot;Löve&quot;&gt;Löve&lt;/a&gt; which is really easy to set up and do rapid development with, however it
didn’t support mobile (officially) which was why I went with Moai. However I found this &lt;a href=&quot;http://love2d.org/forums/viewtopic.php?f=12&amp;amp;t=76985&quot; title=&quot;Löve for iOS&quot;&gt;branch&lt;/a&gt; of Löve which
touted some support for iOS (and it was branched off a branch with support for Android), so I grabbed that and decided to
use that for the rest of the week. I had to rewrite all of the stuff from my prototype, which was done with nothing but
gamepad controls support, plus it was a prototype, and that’s what you do with prototype code. By the end of the week I
had my mobile version with touch controls but not much else than my prototype had (in fact, slightly less), which was kind
of disappointing. And when I went to implement the next part of my game I realized that I was really going to end up needing
3D support, but only for the background. While this may be possible with Löve, it’s not what it’s designed for and it would
be a hack, even moreso than the mobile support (which is actually quite good), and I just didn’t want to go down that road.&lt;/p&gt;

&lt;p&gt;So I came to the conclusion that what I’m really going to have to do is set up an OpenGL context of my own and basically do
what I wanted Moai to do, but on a smaller (more focused) scale. I plan on using &lt;a href=&quot;http://libsdl.org&quot; title=&quot;SDL 2&quot;&gt;SDL&lt;/a&gt; to handle windowing and input,
but that means using C++, which I don’t know very well. I’m considering doing lua bindings for the pieces of SDL that I need,
as I couldn’t get the SDL-lua bindings that I found to build on my machine and I didn’t want to go down that hole again.&lt;/p&gt;

&lt;p&gt;So all that to say: I got the wind taken out of my sails for the current game idea and I need to take a step back and try
again with something smaller, which brings me to…&lt;/p&gt;

&lt;h1 id=&quot;a-game-a-week&quot;&gt;A Game a Week&lt;/h1&gt;

&lt;p&gt;Inspired by &lt;a href=&quot;http://www.gamasutra.com/blogs/RamiIsmail/20140226/211807/Game_A_Week_Getting_Experienced_At_Failure.php&quot; title=&quot;A Game A Week - Gamasutra&quot;&gt;this post&lt;/a&gt; by &lt;a href=&quot;http://ramiismail.com&quot; title=&quot;Rami Ismail of Vlambeer&quot;&gt;Rami Ismail&lt;/a&gt; (and &lt;a href=&quot;http://msminotaur.com/blog/?cat=4&quot; title=&quot;Game a Week&quot;&gt;this blog&lt;/a&gt; by &lt;a href=&quot;http://msminotaur.com&quot; title=&quot;@msminotaur&quot;&gt;Adriel Wallick&lt;/a&gt;), I’m going
to start building (and releasing) a game a week. The gist of the idea is that you build lots of &lt;em&gt;little&lt;/em&gt; games and put them
out there for people to play. Get the experience of making something and finding out what sucks, what doesn’t, and why. But
doing so with tiny projects that you’re not sinking too much time/energy into. Another big part of this is that you don’t
touch the game again after the release, at least not as part of the Game a Week challenge. You can pick the game up later
and turn it into a full sized project, but each week is supposed to be something completely new. For my first few weeks I’m
going to keep it super duper simple, like Pong and Breakout clone simple, so that I can get an engine of sorts pieced together.
After I get a few of those out of the way and have some tools to work with I’ll start getting a little more adventurous with
my ideas.&lt;/p&gt;

&lt;p&gt;Along with the game each week I’ll be posting a post-mortem about it here, to log the process and provide access to the game!
It’s also possible that I’ll be posting about the week’s game throughout the week, depending on progress, of course.&lt;/p&gt;

&lt;p&gt;I’m not sure how long I’ll do the challenge, but my initial goal is going to be 8 weeks, starting next week. This post is the
first step in the process and I’ll probably get started on the Pong clone this week, even though it’ll be a short week, so I
can get the initial project set up stuff out of the way and be ready to go for reals next week.&lt;/p&gt;

&lt;p&gt;Anyway, I hope you’ll come back and try my games on this challenge, and send me some feedback on &lt;a href=&quot;http://twitter.com/aranasaurus&quot;&gt;twitter&lt;/a&gt;!&lt;/p&gt;

</description>
				<pubDate>Thu, 23 Oct 2014 09:42:00 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/23/game-dev-week/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/23/game-dev-week/</guid>
			</item>
		
	</channel>
</rss>
