<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>The Aranasaurus Nest</title>
		<description>Where @aranasaurus keeps his code and things</description>
		<link>http://aranasaurus.com</link>
		<atom:link href="http://aranasaurus.com/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Pac-Man Ghost AI Demo</title>
				<description>&lt;p&gt;Have you ever noticed how the ghosts in Pac-Man don’t all chase him in the same fashion? Does that kind of thing
pique your interest?  Well, it does mine! So I built a thing that visualizes their AI strategies and that’s what
this post is going to be all about.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&quot;history&quot;&gt;History&lt;/h1&gt;

&lt;p&gt;I forget why I went Googling for the ghost AI’s once many years ago, but when I did I found &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html&quot; title=&quot;The Pac-Man Dossier&quot;&gt;The Pac-Man Dossier&lt;/a&gt;,
and subsequently read it cover to cover (or top to bottom, as the case may be). I found the info in Chapters
2-4 to be a fantastic study on game design in general, but more specifically game &lt;em&gt;AI&lt;/em&gt;. The fact that this
game is still challenging and fun to this day is a testament to just how well-tuned these AI algorithms are
(a nod should also be given to all of the other aspects of the game design as well, but I digress). With
just these 4 ghosts the developers have been able to keep Pac-Man players on their toes for 30+ years.&lt;/p&gt;

&lt;p&gt;More recently though, I was going through the &lt;a href=&quot;//www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/route-finding&quot; title=&quot;Route Finding, Computer Science - Khan Academy&quot;&gt;Route Finding&lt;/a&gt; lesson on &lt;a href=&quot;//www.khanacademy.org&quot; title=&quot;Khan Academy&quot;&gt;Khan Academy&lt;/a&gt; and it
used Pac-Man and his paranormal buddies as an example use case for path/route finding. I knew from my time
with the &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html&quot; title=&quot;The Pac-Man Dossier&quot;&gt;dossier&lt;/a&gt; though, this was not &lt;em&gt;entirely&lt;/em&gt; accurate. The ghosts don’t actually do any path finding. They just measure
distance, in tiles from their current (more accurately, their next) tile to their target tile. This measurement
ignores walls and other obstacles, it’s an “as the crow flies” measurement, which, strictly speaking, is not
path finding at all.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;//xkcd.com/386/&quot;&gt;&lt;img src=&quot;//imgs.xkcd.com/comics/duty_calls.png&quot; alt=&quot;Wrong on the internet!&quot; title=&quot;xkcd - Wrong on the Internet&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;the-demo&quot;&gt;The Demo&lt;/h1&gt;

&lt;p&gt;One of the cool things about &lt;a href=&quot;//www.khanacademy.org&quot; title=&quot;Khan Academy&quot;&gt;Khan Academy&lt;/a&gt; is that they have a platform for creating interactive demos which
can be forked (or Split Off, as they call it), shared, even embedded into pages… like this:&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;http://www.khanacademy.org/computer-programming/pac-man-ghost-ai-visualisation/6163767378051072&quot;&gt;Pac-Man Ghost AI Visualization&lt;/a&gt;&lt;/h2&gt;
&lt;script src=&quot;http://www.khanacademy.org/computer-programming/pac-man-ghost-ai-visualisation/6163767378051072/embed.js?editor=no&amp;amp;buttons=yes&amp;amp;author=yes&amp;amp;embed=yes&quot;&gt;&lt;/script&gt;
&lt;p style=&quot;padding:4px&quot;&gt;Made using: &lt;a href=&quot;http://www.khanacademy.org/computer-programming&quot;&gt;Khan Academy Computer Science&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I made that demo/visualization, not (solely) because “Someone is wrong on the internet”, but because I thought
it’d be a fun exercise to write and, if I was successful, a fun little program to show the elegance of the
Pac-Man ghost AI algorithms without having to read the whole Dossier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: You can view the (javascript/&lt;a href=&quot;//processingjs.org&quot; title=&quot;Processing.js&quot;&gt;processing.js&lt;/a&gt;) code, which is pretty well commented, and even fork it
and make changes to it if you want by clicking the “View on Khan Academy” button above.&lt;/p&gt;

&lt;h2 id=&quot;graphics&quot;&gt;Graphics&lt;/h2&gt;

&lt;p&gt;The demo runs the AI algorithms for each ghost as laid out in the &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html&quot; title=&quot;The Pac-Man Dossier&quot;&gt;dossier&lt;/a&gt; and then renders some extra graphics to show
the information they used/calculated to make their choices of where to go:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A tile outline of each ghost’s color which represents that ghost’s current target tile.&lt;/li&gt;
  &lt;li&gt;A transparent representation of the ghost and the direction it will go when it gets to the next tile. The
 ghosts always plan their moves one tile in advance.&lt;/li&gt;
  &lt;li&gt;Lightly outlined tile(s) with a number in it. These tiles represent the tiles that the ghost considered when
 choosing the direction to go in the next tile. The numbers represent the distance from that tile to that ghost’s
 current target tile.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The demo simulation runs by tile. Whereas the game shows the characters runing fluidly between the tiles, the
algorithms themselves only care about the tile the character is in, so making it advance per tile made it easy
to see how things go step by step.&lt;/p&gt;

&lt;h2 id=&quot;controls&quot;&gt;Controls&lt;/h2&gt;

&lt;p&gt;You can use the arrow keys (or WASD) to move Pac-Man step by step through the simulation, or if you hold Shift
and press the movement keys, you can change the direction that Pac-Man is facing and force all of the ghosts to
recalculate their target tile. This is important to note because you’ll notice that the target tiles don’t
update themselves every step. This is because the ghosts only update their target tile when they have a choice
to make, and since they can never go backward, they only have a choice when they’re at an intersection in the
maze. This also allows you to see how you can “control” the paths of some of the ghosts at certain points.&lt;/p&gt;

&lt;p&gt;You can also use the 1-4 number keys (or the first letter of each ghost’s name: Blinky, Pinky, Inky, Clyde) to
toggle the visibility of each ghost’s decision making graphics. The target tile will always be visible, this
refers only to the numbers and the next tile graphics.&lt;/p&gt;

&lt;h1 id=&quot;how-it-works&quot;&gt;How It Works&lt;/h1&gt;

&lt;h2 id=&quot;first-a-bit-about-pac-man&quot;&gt;First, a bit about Pac-Man&lt;/h2&gt;

&lt;p&gt;For those that haven’t read through the &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html&quot; title=&quot;The Pac-Man Dossier&quot;&gt;dossier&lt;/a&gt; I’d like to give a brief overview of a few points about how the
game works. In playing the game you may have noticed that the ghosts don’t just chase Pac-Man the whole time
(regardless of their strategy for getting &lt;em&gt;to&lt;/em&gt; him), but sometimes they actually run &lt;em&gt;away&lt;/em&gt; from him even if 
Pac-Man hasn’t eaten an energizer dot. This is because the ghosts have three distinct modes that they operate
in, depending on various other factors in the game.&lt;/p&gt;

&lt;p&gt;Here’s a quote from the &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html#CH2_Modus_Operandi&quot; title=&quot;The Pac-Man Dossier&quot;&gt;dossier&lt;/a&gt; that summarizes the three modes quite nicely:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ghosts have three mutually-exclusive modes of behavior they can be in during play: chase, scatter, and frightened. Each mode has a different objective/goal to be carried out:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;CHASE&lt;/strong&gt;—A ghost’s objective in chase mode is to find and capture Pac-Man by hunting him down through the maze. Each ghost exhibits unique behavior when chasing Pac-Man, giving them their different personalities: Blinky (red) is very aggressive and hard to shake once he gets behind you, Pinky (pink) tends to get in front of you and cut you off, Inky (light blue) is the least predictable of the bunch, and Clyde (orange) seems to do his own thing and stay out of the way.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;SCATTER&lt;/strong&gt;—In scatter mode, the ghosts give up the chase for a few seconds and head for their respective home corners. It is a welcome but brief rest—soon enough, they will revert to chase mode and be after Pac-Man again.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;FRIGHTENED&lt;/strong&gt;—Ghosts enter frightened mode whenever Pac-Man eats one of the four energizers located in the far corners of the maze. During the early levels, the ghosts will all turn dark blue (meaning they are vulnerable) and aimlessly wander the maze for a few seconds. They will flash moments before returning to their previous mode of behavior.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Another important note to go along with that is that they can never reverse direction… except when they
switch between the above modes. They can also change their movement &lt;em&gt;speed&lt;/em&gt; at certain numbers of remaining
dots in the level.&lt;/p&gt;

&lt;p&gt;There are other finer points of detail in the &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html&quot; title=&quot;The Pac-Man Dossier&quot;&gt;dossier&lt;/a&gt;, but I think that should cover what we need to know
for this project.&lt;/p&gt;

&lt;h2 id=&quot;the-ghosts-and-their-target-tiles&quot;&gt;The Ghosts and their target tiles&lt;/h2&gt;

&lt;p&gt;As previously stated the ghosts only update their target tile at intersections in the maze. This target
tile calculation is really where the difference in behavior comes from. Here’s a brief explanation of each
of their target tile algorithms (in chase mode). For more in-depth analysis check out &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html#Chapter_3&quot; title=&quot;The Pac-Man Dossier&quot;&gt;Chapters 3-4&lt;/a&gt;
in the &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html&quot; title=&quot;The Pac-Man Dossier&quot;&gt;dossier&lt;/a&gt; or the &lt;a href=&quot;//www.khanacademy.org/computer-programming/pac-man-ghost-ai-visualisation/6163767378051072&quot; title=&quot;Pac-Man Ghost AI Visualization - Khan Academy&quot;&gt;source code&lt;/a&gt; for the demo.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Blinky&lt;/strong&gt; - The red ghost is the most straight forward. Blinky’s target tile is always Pac-Man’s current tile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pinky&lt;/strong&gt; - The pink ghost is pretty straight forward too. Pinky’s target tile is always a tile 4 tiles ahead
 of Pac-Man’s current tile. See the note below about the bug which is replicated in the demo.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Inky&lt;/strong&gt; - The blue ghost takes a three step process to figure out its target tile:
    &lt;ol&gt;
      &lt;li&gt;Find the tile 2 tiles in front of Pac-Man.&lt;/li&gt;
      &lt;li&gt;Find the vector between Blinky and the tile in step 1.&lt;/li&gt;
      &lt;li&gt;Double the length of that vector. The other end of that vector is Inky’s new target tile.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Clyde&lt;/strong&gt; - The orange ghost has two different modes for picking his next target tile. He switches between these
 modes based on his proximity to Pac-Man:
    &lt;ul&gt;
      &lt;li&gt;When Clyde is within 8 tiles of Pac-Man: Clyde targets a tile just off the maze at the bottom left.&lt;/li&gt;
      &lt;li&gt;When Clyde is farther than 8 tiles away from Pac-Man: Clyde targets Pac-Man’s tile, the same way Blinky
does.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Pinky’s and Inky’s “&lt;em&gt;x&lt;/em&gt; tiles in front of Pac-Man” measurements work as you’d expect in every direction
 except for up. There was a bug in the original game that when they did this measurement in the up direction
 they actually measured &lt;em&gt;x&lt;/em&gt; tiles up &lt;strong&gt;AND&lt;/strong&gt; &lt;em&gt;x&lt;/em&gt; tiles to the left. This bug is replicated in the demo (on
 purpose).&lt;/p&gt;

&lt;h2 id=&quot;differences-from-the-game-in-the-demo&quot;&gt;Differences from the game in the demo&lt;/h2&gt;

&lt;p&gt;I really wanted this thing to be as focused on the Chase mode strategies of the ghosts as possible. In order
to do that I made the following choices:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;There are no pellets. The pellets are very important for the game, but not so much for the chase mode 
 strategies of the ghosts. Also I really didn’t want the added visual clutter.&lt;/li&gt;
  &lt;li&gt;There are no mode or speed changes. I wanted to focus on the chase mode strategies specifically, since
 the other modes are relatively uninteresting. Since there are no pellets there are also no speed changes.&lt;/li&gt;
  &lt;li&gt;No collision detection between ghosts and Pac-Man. I didn’t want this to be a playable version of the
 game so the death sequence just didn’t make a lot of sense to try and imitate and there’s a handy Restart
 button for anytime you want to reset everything. I may go back and add some kind of messaging when a ghost
 touches Pac-Man later, but for now it seems fine without it.&lt;/li&gt;
  &lt;li&gt;Tile based movement. The real Pac-Man runs fluidly at so many frames per second, and the characters all
 move from tile to tile pixel by pixel. I wanted to be able to show how things are done step by step and the
 algorithms are all tile based so I decided to just advance the game world by one step every time Pac-Man
 enters a new tile. There are some edge cases where this means that this demo will behave differently from
 the actual game (like &lt;a href=&quot;//home.comcast.net/~jpittman2/pacman/pacmandossier.html#CH3_Just_Passing_Through&quot; title=&quot;The Pac-Man Dossier&quot;&gt;here&lt;/a&gt;), but I figured this was a trade off I was willing to
 make.&lt;/li&gt;
  &lt;li&gt;Distances for the algorithms are scaled. In the actual game the mazes have more tiles in them than in
 the demo, so for my implementation of the algorithms I scale the distances used in them to account for that.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Turns out I was definitely right about the fun to write part. Whether or not it’s fun &lt;em&gt;to play&lt;/em&gt; or demonstrates
the AI in an easy to understand fashion, I’ll let you be the judge of. I hope it’s as fun for everyone else to
play around with as it is for me, because every time I open the damn thing I end up running Pac-Man around for
way more time than I intended to! Therefor, I’m going to consider the project a success overall.&lt;/p&gt;

</description>
				<pubDate>Sat, 10 Jan 2015 16:09:05 -0800</pubDate>
				<link>http://aranasaurus.com/2015/01/10/pac-man-ghost-ai-demo/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2015/01/10/pac-man-ghost-ai-demo/</guid>
			</item>
		
			<item>
				<title>LD31</title>
				<description>&lt;p&gt;Earlier this month I (partially) participated in &lt;a href=&quot;http://ludumdare.com/compo/2014/12/03/welcome-to-ludum-dare-31/&quot; title=&quot;LD31&quot;&gt;Ludum Dare 31&lt;/a&gt;. I say partially, because I had a lot of family stuff going on that was
going to take up most of my weekend, as I &lt;a href=&quot;https://twitter.com/aranasaurus/status/540945881021677568&quot; title=&quot;Twitter&quot;&gt;tweeted&lt;/a&gt; earlier in the week. But on Friday night after putting the kids to sleep I
checked the theme and saw that it was one of the ones I had actively voted &lt;em&gt;against&lt;/em&gt;: “Entire game on one screen”. So I was like, “Well, I guess
it’s for the better; I didn’t want that theme anyway, so this’ll make it easier for me to ignore the compo/jam.” But then ideas started pouring
into my head and some of them seemed like they were pretty good, too! I sat there, unable to sleep as I rolled these ideas through the tumbler
over and over until I landed on an idea that not only sounded good, but I had a pretty good handle on &lt;em&gt;how&lt;/em&gt; to do it and it &lt;em&gt;might&lt;/em&gt; even be able
to be completed in the &amp;lt; 24 hours I’d be able to commit to the jam. &lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&quot;the-game-for-the-jam&quot;&gt;The Game For the Jam&lt;/h1&gt;

&lt;p&gt;The initial game idea for the jam was pretty simple. It’s a &lt;a href=&quot;http://en.wikipedia.org/wiki/Shoot_%27em_up#Multi-directional_shooter&quot; title=&quot;Twin-stick Shooter - Wikipedia&quot;&gt;twin-stick shooter&lt;/a&gt; (aka arena shooter) similar in look and feel
to &lt;a href=&quot;http://en.wikipedia.org/wiki/Geometry_Wars&quot; title=&quot;Geometry Wars - Wikipedia&quot;&gt;Geometry Wars&lt;/a&gt; but with an &lt;a href=&quot;http://en.wikipedia.org/wiki/Ikaruga&quot; title=&quot;Ikaruga - Wikipedia&quot;&gt;Ikaruga&lt;/a&gt; twist. The sub-genre in and of itself seemed like a very pedestrian and obvious
choice for the theme since games of this sub-genre typically occur entirely on one screen anyway. I figured I’d make all of the menus for starting
and restarting the game objects that you shoot, to take it that extra step toward the theme, but still, a Geometry Wars clone is not a particularly
interesting game jam entry. So the other, more interesting bit, was to make the game spawn all of the enemies and power ups on its own, all
roguelike-y. My idea for how to do this was to use the lasers that the player shoots, when two lasers collide they have a random chance to spawn
a power up or an enemy. Then I wanted to make it so that the player could have some input into this, or affect the randomness somehow, so I came
up with the ship and shield colors idea, which would be where the Ikaruga twist comes in.&lt;/p&gt;

&lt;p&gt;The player can change the color of their ship through the three &lt;a href=&quot;http://en.wikipedia.org/wiki/RYB_color_model&quot; title=&quot;RYB - Wikipedia&quot;&gt;primary colors&lt;/a&gt;. They can also, independently change the color of
their shields through the same colors. The combination of their ship and shield color determine the color of the lasers they shoot: blue ship with
a yellow shield shoots green lasers. This combination also determines the amount of damage they take when being hit by a laser. When lasers collide
the colors of the colliding lasers determine which pool of enemies or powerups the game will choose from if it determines that this collision will
generate anything at all. So an orange and a purple laser colliding might spawn the Spread Laser power-up, Reflect Shield or EnemyA or EnemyC, but
a green and blue laser collision might spawn a Health Orb, a Time Warp orb, or EnemyB or EnemyC, and so on.&lt;/p&gt;

&lt;h2 id=&quot;progress-made-during-the-jam&quot;&gt;Progress Made During the Jam&lt;/h2&gt;

&lt;p&gt;I decided to go with &lt;a href=&quot;http://www.love2d.org&quot; title=&quot;Löve&quot;&gt;Löve2D&lt;/a&gt; for the game, since I’ve worked a fair amount with it in the past and felt like I could get up and running
pretty quickly with it. And I was, the more I play with that engine the more I really like it. It is the perfect combination of minimalism and
practicality and it just lets me get in there and make things my way without imposing much on me. And its &lt;a href=&quot;http://love2d.org/wiki&quot; title=&quot;Löve Docs&quot;&gt;docs&lt;/a&gt; are really well
done and helpful, I can almost always figure out exactly what I need to do to make something in the engine do what I want it to in a very short
amount of time.&lt;/p&gt;

&lt;p&gt;The one thing that Löve doesn’t have that some other 2d frameworks have is easy to use collision detection. They have a Box2D wrapper, but that’s
really way more than what I needed for this game. As such, a large chunk of my time during the jam was spent doing collision detection and vector
math. I’m actually really happy that Löve doesn’t have this as this time my attempts at learning all of this vector math and trigonometry for
collision detection actually stuck and I really feel like I learned something; like I got over a hurdle that I’ve stumbled over many times in my
past. I found a lot of help on this subject in &lt;a href=&quot;https://www.youtube.com/playlist?list=PLW3Zl3wyJwWOpdhYedlD-yCB7WQoHf-My&quot; title=&quot;Math for Game Developers - youtube&quot;&gt;these videos&lt;/a&gt; and this &lt;a href=&quot;http://higherorderfun.com/blog/2012/06/03/math-for-game-programmers-05-vector-cheat-sheet&quot; title=&quot;Vector Cheat Sheet&quot;&gt;cheatsheet&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Another thing I spent a lot of time on during the jam (and ultimately ended up removing after the jam, unfortunately) was the color combination code.
As you may know in the RGB space adding yellow and blue does not get you green (it gets you white). I wrote code to convert colors to CMYK then
do the combination and then convert back to RGB (based on this &lt;a href=&quot;http://stackoverflow.com/a/15244944/52561&quot; title=&quot;Natural Color Combination - Stack Overflow&quot;&gt;Stack Overflow answer&lt;/a&gt;). I ended up removing it later on because
with only 6 colors it makes more sense to hand pick the colors and then do the logic of combining them manually so that I end up with better colors
overall, as the algorithm used kinda muddies up the colors a little bit.&lt;/p&gt;

&lt;p&gt;As I said before I didn’t have the full 72 hours to commit to the jam due to other obligations, but I was able to carve out a couple of 3 hour chunks
over the weekend, and then took the day off from work on Monday to try to finish. So in all, I had just under 20 hours to put in to the game. This
was, unfortunately not enough for me to get to a place where I felt I could submit anything. At submission time I had the ship on the screen and
lasers bouncing around and colliding with each other and the ship, but I had no enemies, no power-ups, no scoring, no menu system, no sound (effects
or soundtrack), basically no game, just a barely functional prototype. But it was a great start, a solid framework to start hanging the fun ideas
for this project off of. I created a &lt;a href=&quot;https://github.com/aranasaurus/prism-game/tree/end-of-jam&quot; title=&quot;Prism (end-of-jam) - GitHub&quot;&gt;tag on the repo&lt;/a&gt; to mark my progress at the submission deadline, if you’re interested.&lt;/p&gt;

&lt;h1 id=&quot;after-the-jam&quot;&gt;After the Jam&lt;/h1&gt;

&lt;p&gt;So I’ve been all super inspired about this game idea since the jam and have thusly put quite a few hours into improving it over the past month or so.
The only thing from the list of things I didn’t have at the submission deadline that I &lt;em&gt;do&lt;/em&gt; have now is scoring. Which I added about 1 hour after
the submission deadline. But I have spent a lot of time tweaking and improving things to clean up that “get it done quick” code that I didn’t
want sticking around in a more permanent project. Also: bug fixes and memory leaks.&lt;/p&gt;

&lt;p&gt;I spent a fair amount of time getting a Bloom shader into the game for the lasers and the shields to pretty it up a bit. This was the first time
I’ve ever done any GLSL stuff and it was a great learning experience. I’ll do a full post about that in the near future. I’m pretty darn happy
with the look as it stands, I still need some font work and a better ship sprite, but overall it looks pretty damn good for programmer art.&lt;/p&gt;

&lt;p&gt;I’ve added keyboard controls since the jam as well. They suck, but that’s the nature of this style of game, you pretty much just need to have a
gamepad to really make it feel right.&lt;/p&gt;

&lt;p&gt;The other thing I’ve spent a lot of time on since the jam is nailing down exactly what I want actually in the game, and I still haven’t finished
that process! I’ve got a pretty good roadmap in my &lt;a href=&quot;https://github.com/aranasaurus/prism-game/issues&quot; title=&quot;Prism Issues - GitHub&quot;&gt;issues list&lt;/a&gt; on the repo for what needs to be coded up next, but I think ultimately
the rest of my game design decisions are going to have to be made after implementing some of the ideas, trying them out, and going from there.&lt;/p&gt;

&lt;p&gt;During the jam I never actually landed on a usable name. I have since done that, as well.&lt;/p&gt;

&lt;h2 id=&quot;the-name&quot;&gt;The Name&lt;/h2&gt;

&lt;p&gt;The color combination thing kind of made the player ship seem like a prism to me, in fact when I went and looked it up on &lt;a href=&quot;http://en.wikipedia.org/wiki/Prism&quot; title=&quot;Prism - Wikipedia&quot;&gt;wikipedia&lt;/a&gt;
the following quote described what the player ship was essentially doing quite nicely:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A dispersive prism can be used to break light up into its constituent spectral colors (the colors of the rainbow). Furthermore, prisms can be
used to reflect light, or to split light into components with different polarizations. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So that’s how I ended up on the name “Prism”.&lt;/p&gt;

&lt;h1 id=&quot;now-what&quot;&gt;Now What?&lt;/h1&gt;

&lt;p&gt;My &lt;a href=&quot;https://github.com/aranasaurus/prism-game/issues&quot; title=&quot;Prism Issues - GitHub&quot;&gt;issues list&lt;/a&gt; gives a pretty good idea of where I want to go with the game, but what I’m focusing on in the short term is getting
the power-ups and enemies spawning so that the game really starts to feel like a game! I’ve had a bit of Analysis Paralysis the past week or so and
keep putting off doing the power-ups because I’m having a hard time figuring out how best to implement them. It’s a much more difficult problem
to solve than I thought it would be! I may end up writing a post about that in the near future as well, once I settle on how to do it and get it done.&lt;/p&gt;

&lt;p&gt;I’ll get back to updating this site on a more regular basis again now, and I’m sure Prism will be a frequent topic of these posts in the near-term at
least.&lt;/p&gt;

</description>
				<pubDate>Tue, 23 Dec 2014 19:23:19 -0800</pubDate>
				<link>http://aranasaurus.com/2014/12/23/ld31/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/12/23/ld31/</guid>
			</item>
		
			<item>
				<title>Testability</title>
				<description>&lt;p&gt;I’ve been working on a project at work for the past few months that started with a basic idea of what was
required of it, and then after a series of proof-of-concept demos we now have a better idea of what this
thing needs to do, and more importantly &lt;em&gt;how&lt;/em&gt; it needs to do it. This type of organic development process
is great, but it can have some side effects for the code base. Primarily there are some code paths that
made it into the code base to support some functionality that is no longer required, as well as some
implementations allowing for requirements that have either gone away or changed, leaving some strange
looking implementation artifacts. Secondarily we did not have time to write tests and setup CI and all
those other best practice and stability things. I spent most of my week addressing these two things.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&quot;code-clean-up&quot;&gt;Code clean up&lt;/h1&gt;

&lt;p&gt;We did some refactoring a couple weeks back to get some of the more egregious code smells taken care of, where
we had gone partially down a path for some functionality and then abandoned that bit of functionality, yet the
code still had some artifacts of it left over.&lt;/p&gt;

&lt;p&gt;After (and during) that, it became apparent that the next thing we needed to do (for our sanity), was tests.
It’s really hard to tell when a new feature you’ve added is &lt;em&gt;really&lt;/em&gt; working the way you &lt;em&gt;think&lt;/em&gt; it is. Verifying
a bug-fix didn’t just make a new bug in the process is also really hard when you’ve no tests to prove it.&lt;/p&gt;

&lt;p&gt;In looking at writing some tests for the project we quickly found that some restructuring was going to be required.
And that is what I’ve been doing with most of my week; Refactoring a bunch of functioning code into testable
units.&lt;/p&gt;

&lt;h1 id=&quot;testable-units&quot;&gt;Testable Units&lt;/h1&gt;

&lt;p&gt;The first thing I did was diagram all of the components as they were currently implemented and map out the
communication points between them. That basically gave me each component’s current API. Sure there are easier
ways to do this, but visualizing it was very helpful for me. It allowed me to move things around and really get
the big picture (pun!) in my head all at once.&lt;/p&gt;

&lt;p&gt;Then I drew up a new diagram which moved some of the responsibilities around from one component to another. This
involved collapsing a couple classes into other classes where the complexity added for communication between the
classes did not outweigh the benefit from separating them. There were also cases where I made a new class to
separate out the more complicated pieces where the benefits of separation &lt;em&gt;did&lt;/em&gt; outweigh the complexity imposed
by communication.&lt;/p&gt;

&lt;p&gt;I did a few iterations on this diagram and boiled it down to what I thought was the core set of components needed
with very specific inputs and outputs defined for their interfaces and then went over it with the rest of my team.
The new design made sure that each component had very specific inputs and outputs that could be generated by hand,
as opposed to the previous design which took a lot of the data required to do its work either from the operating
system directly or from internal properties which were the output of other processes.&lt;/p&gt;

&lt;p&gt;Therein lies the key to making the thing testable: specific inputs and outputs and compartmentalized actions.
The most basic requirements to make something ‘Testable’.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;This all may sound obvious, at least it does to me upon review, but when dealing with things like location as
do most things I work on at work, crafting these things based on inputs and outputs of your own code as opposed
to events from the device/system becomes less straight forward. This week’s refactor was a bit of revelation
in this regard for me, and I wanted to write about it. So here we are, this is me, telling you that separation
of concerns and clearly defined, testable APIs with discrete inputs and outputs are a good thing. You probably
already knew that, but sometimes it’s worth saying again.&lt;/p&gt;

&lt;p&gt;The other thing of note here is that the mere process of making this code &lt;em&gt;testable&lt;/em&gt;, led to restructuring it
in a way that made it far more loosely coupled, which is an improvement in stability even without having written
a single test.&lt;/p&gt;

</description>
				<pubDate>Sat, 08 Nov 2014 23:05:24 -0800</pubDate>
				<link>http://aranasaurus.com/2014/11/08/testability/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/11/08/testability/</guid>
			</item>
		
			<item>
				<title>Slaying the C/C++ Dragon</title>
				<description>&lt;p&gt;Work has been pretty busy this week so my off-time has been spent reading more than coding.
And now that I’ve decided that I’ll be making my own “engine” and using C or C++ for a large
portion of it, my next task is to decide between C and C++.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I found &lt;a href=&quot;http://www.amazon.com/C-Easily-SDL2-Stephen-Jones-ebook/dp/B00JVAO3OO&quot;&gt;a book&lt;/a&gt; that sounded like exactly what I needed to see how this could be
done in straight C and it was on Kindle Unlimited so I could just read it for “free”. So I
did, it was pretty short. It did a pretty good job of showing me the &lt;em&gt;how&lt;/em&gt;, I’m just not sure
I agree with all of the &lt;em&gt;whys&lt;/em&gt;. Or, at least, I don’t think the &lt;em&gt;whys&lt;/em&gt; make up for the
limitations imposed by going straight C. So, ultimately I’ve decided I’m going to go with
C++11.&lt;/p&gt;

&lt;p&gt;So I grabbed a copy of &lt;a href=&quot;http://www.stroustrup.com/Tour.html&quot;&gt;&lt;em&gt;A Tour of C++&lt;/em&gt;&lt;/a&gt; to get some familiarity with C++11, since
all of my C++ books are pretty old. Learning C++ has been a long running challenge for me and
this project is my chance to finally slay that dragon.&lt;/p&gt;

&lt;p&gt;I started trying to learn C++ back in high school and had limited success. I started with
a Borland C++ Compiler user’s manual, which was probably my first mistake. I tried several times
over the years and a made a few small things, but never kept with it long enough for the
intricacies of the language to really sink in. I’ve been doing Objective-C professionally for
a few years now though, and that has provided some level of additional comfort with C++, but
this is still going to take quite a bit of learning on my part to actually do this. C++ has
some functionality that Objective-C lacks that I’m really looking forward to getting some
familiarity with (Templates/Generics primarily).&lt;/p&gt;

&lt;p&gt;I’m still reading &lt;em&gt;A Tour of C++&lt;/em&gt;, I’m about halfway through, and I’m feeling more and more
comfortable with C++. I’m hoping to get back to writing some code for the engine next week,
since work should ease up now that our recent deadline/demo has been done and we have a bit
of “slack” time, so I should have more code writing energy when I get home next week.&lt;/p&gt;

&lt;h1 id=&quot;other-stuff&quot;&gt;Other Stuff&lt;/h1&gt;

&lt;h2 id=&quot;pixel-art&quot;&gt;Pixel Art&lt;/h2&gt;

&lt;p&gt;I also stumbled across these &lt;a href=&quot;https://www.youtube.com/user/achebit/playlists&quot;&gt;video series&lt;/a&gt; (both the “How To Pixel Art”
series and the “Pyxel Edit Tutorial Mini Series”) and am now thoroughly inspired
and excited to make my own pixel art! Which is weird for me, I’ve always wanted (not just
needed, but &lt;em&gt;wanted&lt;/em&gt;) to have someone else do art for me, because I’m generally not very
good at it and not really interested in putting in the time to get better at it. However,
after watching those videos I feel like not only &lt;em&gt;can&lt;/em&gt; I do some art, but I really &lt;em&gt;want&lt;/em&gt;
to! So look forward to some of that coming here in the near future.&lt;/p&gt;

&lt;h2 id=&quot;jonathan-blows-new-language&quot;&gt;Jonathan Blow’s New Language&lt;/h2&gt;

&lt;p&gt;I also watched Jonathan Blow’s &lt;a href=&quot;https://www.youtube.com/watch?v=UTqZNujQOlA&quot;&gt;latest talk and demo&lt;/a&gt; about the new game development
focused programming language he wants to create. He has some good points and I look forward
to seeing where he goes with the idea. In his previous talks on the subject he mentioned
how Go-lang was close to being what he wanted out of a programming language for games,
however it’s garbage collected and that meant it was unacceptable (to him) for game
development. I bring that up because the syntax in the demo looks pretty similar to Go, so
that’s interesting. I sent him an email after the first talk suggesting that he look into
modifying Go (it’s an open language) and remove the garbage collection, or work in a way to
disable it and do manual memory management. I didn’t expect to get a response (and didn’t),
but I still think it’s worth looking into, at least.&lt;/p&gt;

</description>
				<pubDate>Sun, 02 Nov 2014 17:13:57 -0800</pubDate>
				<link>http://aranasaurus.com/2014/11/02/slaying-the-dragon/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/11/02/slaying-the-dragon/</guid>
			</item>
		
			<item>
				<title>Game a Week, on Second Thought...</title>
				<description>&lt;p&gt;After just a few days of the game a week challenge I realized that I’m not ready to start that yet. Not if I want
to succeed at it anyway, and not if I want to use my own engine as opposed to Unity or something similar.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I still think the process I was going through of documenting my thought process and progress was helpful and
I’m going to continue to do that while I make my engine and use it to make those first few simple clones
that I was going to do for the Game a Week challenge.&lt;/p&gt;

&lt;p&gt;In other words, I’m not gonna do Game a Week for a few more weeks, but I &lt;em&gt;am&lt;/em&gt; gonna keep posting stuff here
similar to my first few Game a Week posts. I’ll probably go back and edit those posts a little too and structure
them as generic development posts as opposed to Game a Week journal entries. You know… for posterity.&lt;/p&gt;

</description>
				<pubDate>Thu, 30 Oct 2014 16:42:16 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/30/game-a-week-on-second-thought/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/30/game-a-week-on-second-thought/</guid>
			</item>
		
			<item>
				<title>Thoughts on Engine Design and Implementation</title>
				<description>&lt;p&gt;Today I wanted to get it figured out where the line will be drawn as to which logic is written in C/C++ and what
gets done in Lua.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I started off with reading the relevant chapters in &lt;a href=&quot;http://www.lua.org/pil&quot; title=&quot;Programming in Lua, AKA The Lua Bible&quot;&gt;Programming in Lua&lt;/a&gt;. From that I basically came to the
conclusion that the differences between making C functions callable from Lua vs executing Lua scripts from within
C are pretty negligible. So it becomes a matter of preference: Do I want the engine to be rooted in C/C++ with the
ability to delegate game logic implementation off to Lua? Or do I want the engine (and game logic) to be rooted in
Lua and the only C/C++ code being there to expose SDL, OpenGL, and any other C libraries I end up using for physics,
audio, animation, etc to Lua?&lt;/p&gt;

&lt;p&gt;Let’s examine these two options in a bit more detail.&lt;/p&gt;

&lt;h1 id=&quot;engine-in-cc&quot;&gt;Engine in C/C++&lt;/h1&gt;

&lt;p&gt;Doing the engine in C will of course mean more C code needing to be written by me, which I don’t particularly
enjoy. However, it’ll also mean that the hard part of the game(s) will be a bit more straight forward, as there
will only be one level of abstraction, and it’ll be more cleanly separated from the game logic. Basically meaning
I’ll be writing more C/C++ at first, but later on, when I’m doing mostly game-specific implementation, I’ll be in
Lua land.&lt;/p&gt;

&lt;p&gt;Let’s take a look at how this might be modeled.&lt;/p&gt;

&lt;h3 id=&quot;cc-responsibilities&quot;&gt;C/C++ Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Set up window and OpenGL Context.&lt;/li&gt;
  &lt;li&gt;Manage game loops.&lt;/li&gt;
  &lt;li&gt;Maintains a list of game objects.&lt;/li&gt;
  &lt;li&gt;Render loop uses properties on game objects to determine how to draw them.&lt;/li&gt;
  &lt;li&gt;Update loop calls an update function on game objects.&lt;/li&gt;
  &lt;li&gt;Handle input and pass it off to game objects that care about it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lua-responsibilities&quot;&gt;Lua Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Game objects are defined as Lua tables with attributes for location and dimensions and possibly a texture name.&lt;/li&gt;
  &lt;li&gt;Game objects have an update method which allows for updating their attributes every tick.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically this set up boils down to the plumbing and architecture stuff being done in C/C++ and then there being a
communication layer between that scaffolding and all of the game objects, which are implemented in Lua.&lt;/p&gt;

&lt;p&gt;After writing this all out I actually like this method a bit more than I did before doing so. Let’s see what that
process does on the other side.&lt;/p&gt;

&lt;h1 id=&quot;engine-in-lua&quot;&gt;Engine in Lua&lt;/h1&gt;

&lt;p&gt;Doing the engine in Lua has the upside of everything being done in Lua and there being no extra layer between the
engine and entities. However, it does involve figuring out a way to get everything, everywhere bound to Lua, which
probably wouldn’t be too hard, but it just feels kinda dirty and like it will actually hinder dev speed a little
because it’ll be making the hard part of this project a bit more complicated without a lot of payoff.&lt;/p&gt;

&lt;p&gt;Anyway let’s map it out.&lt;/p&gt;

&lt;h3 id=&quot;cc-responsibilities-1&quot;&gt;C/C++ Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Glue code which exposes SDL and OpenGL calls to lua.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lua-responsibilities-1&quot;&gt;Lua Responsibilities&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Everything.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This was less helpful than the C/C++ analysis, but I think I’ve come to my decision at any rate.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Looks like I’ll be doing an engine based in C/C++ (which is another decision I’ll need to make very soon) with
game objects/entities implemented in Lua. Hopefully I’ll be able to get started on actually implementing some
functionality along these lines tonight after the kids go to bed and/or tomorrow!&lt;/p&gt;

</description>
				<pubDate>Sat, 25 Oct 2014 19:21:16 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/25/thoughts-on-engine-design-and-implementation/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/25/thoughts-on-engine-design-and-implementation/</guid>
			</item>
		
			<item>
				<title>Week 1, Day 1</title>
				<description>&lt;p&gt;Getting started on this week’s game on Friday night… The first week was already going to be a little funky
because I’d need to get a few pre-requisite things done:&lt;/p&gt;

&lt;!-- more --&gt;

&lt;ul&gt;
  &lt;li&gt;Decide on a framework and language&lt;/li&gt;
  &lt;li&gt;Get &lt;strong&gt;an&lt;/strong&gt; app built with said framework and language&lt;/li&gt;
  &lt;li&gt;Try to templatize that app a little to make starting fresh each week easier&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first few weeks are going to have a lot more engine development than later weeks as well, since I will
be starting from scratch (aside from what &lt;a href=&quot;http://libsdl.org&quot; title=&quot;SDL2&quot;&gt;SDL&lt;/a&gt; gives me, that is) in that regard. So I’m thinking the
first week is actually going to end up being 1.5 weeks.&lt;/p&gt;

&lt;p&gt;Tonight (and well into the wee hours of the morning) I did a bit of research and eliminated the &lt;a href=&quot;http://golang.org&quot; title=&quot;Go&quot;&gt;go-lang&lt;/a&gt; option
as it still can’t be built to iOS as far as I can tell. I’ve settled on SDL for sure, and got a templatizable
Xcode project started which is building to the Simulator. I found &lt;a href=&quot;http://www.ciaranmccormack.com/sdl-2-0-on-ios-using-xcode-opengl-es-2-0-and-c-11/&quot; title=&quot;SDL 2 on iOS - Ciaran McCormack&quot;&gt;this video&lt;/a&gt; quite helpful
in that endeavor. I started a &lt;a href=&quot;http://github.com/aranasaurus/game-a-week&quot;&gt;github repo&lt;/a&gt; for the whole
challenge and put tonight’s progress in there.&lt;/p&gt;

&lt;p&gt;Tomorrow I’ll need to do a bit more reading about doing Lua bindings, and experiment a bit with that and think
about how/if I want to design the engine with respect to that. I’d really much rather be writing game logic
in Lua than C++ for a myriad of reasons not the least of which being that Lua is just so much easier to write
quickly. Engine work will probably still be in C++ (or even C, for that matter), but I want to spend time really
thinking about the separation of concerns and where it makes sense to do the binding between the two.&lt;/p&gt;

</description>
				<pubDate>Sat, 25 Oct 2014 03:54:15 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/25/week-1-day-1/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/25/week-1-day-1/</guid>
			</item>
		
			<item>
				<title>Game Dev Week</title>
				<description>&lt;p&gt;By day I’m a mobile developer working for &lt;a href=&quot;http://www.esri.com&quot;&gt;Esri&lt;/a&gt; at their &lt;a href=&quot;http://pdx.esri.com&quot;&gt;Portland R&amp;amp;D Center&lt;/a&gt;.
By night (and weekend), when not playing with my kids, I really enjoy making games, though. So recently I took a week off
from the day job to work on a game idea I’ve been rolling around for quite some time (while the kids are at school). I had
a prototype working but I wanted to give it my full attention for a week and see where I could get it in that time. I’ll
talk more about the details of the game in other posts, this one is more about the experience of said “Game Dev Week”.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I started off the week trying to get the &lt;a href=&quot;http://getmoai.com&quot; title=&quot;MOAI SDK&quot;&gt;framework&lt;/a&gt; I had chosen to build and work. I really like the way Moai is
supposed to work: you set up a host for each platform you want to support and write a layer that takes the platform specific
stuff (like inputs) and feeds those things to Moai, then all of your game logic is the same for all platforms but you just
have to write the parts that differ. So I really like the &lt;em&gt;idea&lt;/em&gt; of Moai, but I couldn’t get it to work. I don’t want to
say that there’s anything wrong with Moai, per se, but their documentation leaves a lot to be desired and I just wasn’t dev
enough to get it working with my environment and requirements. I spent 2 days trying to do this and ended up giving up, so
that’s a significant portion of my week essentially wasted.&lt;/p&gt;

&lt;p&gt;The original prototype was done in &lt;a href=&quot;http://love2d.org&quot; title=&quot;Löve&quot;&gt;Löve&lt;/a&gt; which is really easy to set up and do rapid development with, however it
didn’t support mobile (officially) which was why I went with Moai. However I found this &lt;a href=&quot;http://love2d.org/forums/viewtopic.php?f=12&amp;amp;t=76985&quot; title=&quot;Löve for iOS&quot;&gt;branch&lt;/a&gt; of Löve which
touted some support for iOS (and it was branched off a branch with support for Android), so I grabbed that and decided to
use that for the rest of the week. I had to rewrite all of the stuff from my prototype, which was done with nothing but
gamepad controls support, plus it was a prototype, and that’s what you do with prototype code. By the end of the week I
had my mobile version with touch controls but not much else than my prototype had (in fact, slightly less), which was kind
of disappointing. And when I went to implement the next part of my game I realized that I was really going to end up needing
3D support, but only for the background. While this may be possible with Löve, it’s not what it’s designed for and it would
be a hack, even moreso than the mobile support (which is actually quite good), and I just didn’t want to go down that road.&lt;/p&gt;

&lt;p&gt;So I came to the conclusion that what I’m really going to have to do is set up an OpenGL context of my own and basically do
what I wanted Moai to do, but on a smaller (more focused) scale. I plan on using &lt;a href=&quot;http://libsdl.org&quot; title=&quot;SDL 2&quot;&gt;SDL&lt;/a&gt; to handle windowing and input,
but that means using C++, which I don’t know very well. I’m considering doing lua bindings for the pieces of SDL that I need,
as I couldn’t get the SDL-lua bindings that I found to build on my machine and I didn’t want to go down that hole again.&lt;/p&gt;

&lt;p&gt;So all that to say: I got the wind taken out of my sails for the current game idea and I need to take a step back and try
again with something smaller, which brings me to…&lt;/p&gt;

&lt;h1 id=&quot;a-game-a-week&quot;&gt;A Game a Week&lt;/h1&gt;

&lt;p&gt;Inspired by &lt;a href=&quot;http://www.gamasutra.com/blogs/RamiIsmail/20140226/211807/Game_A_Week_Getting_Experienced_At_Failure.php&quot; title=&quot;A Game A Week - Gamasutra&quot;&gt;this post&lt;/a&gt; by &lt;a href=&quot;http://ramiismail.com&quot; title=&quot;Rami Ismail of Vlambeer&quot;&gt;Rami Ismail&lt;/a&gt; (and &lt;a href=&quot;http://msminotaur.com/blog/?cat=4&quot; title=&quot;Game a Week&quot;&gt;this blog&lt;/a&gt; by &lt;a href=&quot;http://msminotaur.com&quot; title=&quot;@msminotaur&quot;&gt;Adriel Wallick&lt;/a&gt;), I’m going
to start building (and releasing) a game a week. The gist of the idea is that you build lots of &lt;em&gt;little&lt;/em&gt; games and put them
out there for people to play. Get the experience of making something and finding out what sucks, what doesn’t, and why. But
doing so with tiny projects that you’re not sinking too much time/energy into. Another big part of this is that you don’t
touch the game again after the release, at least not as part of the Game a Week challenge. You can pick the game up later
and turn it into a full sized project, but each week is supposed to be something completely new. For my first few weeks I’m
going to keep it super duper simple, like Pong and Breakout clone simple, so that I can get an engine of sorts pieced together.
After I get a few of those out of the way and have some tools to work with I’ll start getting a little more adventurous with
my ideas.&lt;/p&gt;

&lt;p&gt;Along with the game each week I’ll be posting a post-mortem about it here, to log the process and provide access to the game!
It’s also possible that I’ll be posting about the week’s game throughout the week, depending on progress, of course.&lt;/p&gt;

&lt;p&gt;I’m not sure how long I’ll do the challenge, but my initial goal is going to be 8 weeks, starting next week. This post is the
first step in the process and I’ll probably get started on the Pong clone this week, even though it’ll be a short week, so I
can get the initial project set up stuff out of the way and be ready to go for reals next week.&lt;/p&gt;

&lt;p&gt;Anyway, I hope you’ll come back and try my games on this challenge, and send me some feedback on &lt;a href=&quot;http://twitter.com/aranasaurus&quot;&gt;twitter&lt;/a&gt;!&lt;/p&gt;

</description>
				<pubDate>Thu, 23 Oct 2014 09:42:00 -0700</pubDate>
				<link>http://aranasaurus.com/2014/10/23/game-dev-week/</link>
				<guid isPermaLink="true">http://aranasaurus.com/2014/10/23/game-dev-week/</guid>
			</item>
		
	</channel>
</rss>
